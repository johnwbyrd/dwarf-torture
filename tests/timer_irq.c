/**
 * @file timer_irq.c
 * @brief Test ZBC timer interrupt functionality
 *
 * This test verifies that:
 * 1. SYS_TIMER_CONFIG syscall works
 * 2. Timer fires IRQ at requested rate
 * 3. STATUS register indicates timer tick
 * 4. Writing 0 to STATUS clears the interrupt
 * 5. Timer can be stopped
 */

#include <stdio.h>
#include <stdint.h>

/* ZBC semihost device address for 16-bit CPUs (6502, Z80, etc.)
 * Memory layout: RAM ends at semihost_addr - 1
 * Semihost: 0xFCE0 - 0xFCFF (32 bytes)
 * VRAM:     0xFD00 - 0xFEFF (512 bytes)
 * Reserved: 0xFF00 - 0xFFFF (256 bytes, includes 6502 vectors)
 */
#define SEMIHOST_BASE    0xFCE0

/* Semihost register offsets */
#define SEMIHOST_STATUS  (*(volatile uint8_t *)(SEMIHOST_BASE + 0x19))

/* 6502 IRQ vector location */
#define IRQ_VECTOR       (*(volatile uint16_t *)0xFFFE)

/* Timer tick counter - modified by ISR */
volatile uint16_t irq_count = 0;

/* Expected tick count for test */
#define TARGET_TICKS     10

/**
 * IRQ handler for 6502.
 *
 * The 6502 pushes PC and status register before jumping here.
 * We must acknowledge the interrupt and return with RTI.
 */
__attribute__((interrupt)) void irq_handler(void) {
    /* Check that it's actually a timer interrupt */
    uint8_t status = SEMIHOST_STATUS;
    if (status == 1) {
        /* Timer tick - increment counter */
        irq_count++;

        /* Print digit for each tick */
        putchar('0' + (irq_count % 10));

        /* Acknowledge interrupt by writing 0 to STATUS */
        SEMIHOST_STATUS = 0;
    }
    /* RTI is generated by the compiler for interrupt functions */
}

/* sys_semihost is provided by picolibc's libsemihost */
extern uintptr_t sys_semihost(uintptr_t op, uintptr_t param);

/* SH_SYS_TIMER_CONFIG opcode from zbc_protocol.h */
#define SH_SYS_TIMER_CONFIG 0x32

/**
 * Configure the semihost timer via SYS_TIMER_CONFIG syscall.
 *
 * @param rate_hz  Timer frequency in Hz. 0 = disable.
 * @return 0 on success, negative on error.
 */
static int zbc_timer_config(uint32_t rate_hz) {
    uintptr_t args[1];
    args[0] = rate_hz;
    return (int)sys_semihost(SH_SYS_TIMER_CONFIG, (uintptr_t)args);
}

int main(void) {
    int result;

    printf("ZBC Timer IRQ Test\n");
    printf("==================\n\n");

    /* Install IRQ handler */
    printf("Installing IRQ handler at 0x%04X...\n", (unsigned)(uintptr_t)irq_handler);
    IRQ_VECTOR = (uint16_t)(uintptr_t)irq_handler;

    /* Start timer at 50 Hz */
    printf("Starting timer at 50 Hz...\n");
    result = zbc_timer_config(50);
    if (result != 0) {
        printf("ERROR: zbc_timer_config(50) returned %d\n", result);
        return 1;
    }

    /* Enable interrupts (clear interrupt disable flag) */
    printf("Enabling interrupts...\n");
    __asm__ volatile ("cli");

    /* Wait for TARGET_TICKS interrupts */
    printf("Waiting for %d timer ticks...\n", TARGET_TICKS);
    while (irq_count < TARGET_TICKS) {
        /* Spin - interrupts will increment irq_count */
    }

    /* Disable interrupts */
    __asm__ volatile ("sei");

    /* Stop the timer */
    printf("Stopping timer...\n");
    result = zbc_timer_config(0);
    if (result != 0) {
        printf("ERROR: zbc_timer_config(0) returned %d\n", result);
        return 1;
    }

    /* Report results */
    printf("\nResults:\n");
    printf("  IRQ count: %u\n", irq_count);
    printf("  Expected:  %d\n", TARGET_TICKS);

    if (irq_count >= TARGET_TICKS) {
        printf("\nPASS: Timer IRQ test successful!\n");
        return 0;
    } else {
        printf("\nFAIL: Did not receive expected interrupts\n");
        return 1;
    }
}
